#!./venv/bin/python

# memcfg - A command line utility for managing the Pico KIM-1 Memory Emulator board
#
# Copyright (C) 2024 Eduardo Casino https://github.com/eduardocasino under the terms
# of the GNU GENERAL PUBLIC LICENSE, Version 2
#
import argparse
import requests
import yaml
import re
import sys, os
import struct
from hexdump import hexdump
from intelhex import IntelHex
from io import StringIO
from math import trunc

PROGRAM_NAME     = 'memcfg'
MEM_ATTR_CE_MASK = 1 << 8
MEM_ATTR_RW_MASK = 1 << 9
MEM_DATA_MASK    = 0xFF

hexfmt = re.compile( '^0[xX][0-9A-Fa-f]{1,5}$' )
intfmt = re.compile( '^[0-9]{1,5}$' )
ipaddr = re.compile( '^([0-9]{1,3}[.]){3}[0-9]{1,3}$' )
adrrng = re.compile( '^0[xX][0-9A-Fa-f]{1,4}-0[xX][0-9A-Fa-f]{1,4}$')


# XXXXXX 1 1 XXXXXXXX
# ^^^^^^ ^ ^ ^^^^^^^^
# |||||| | | ++++++++-----> DATA
# |||||| | +--------------> ENABLED (Active low)
# |||||| +----------------> RDONLY  (Active low)
# ++++++------------------> Unused
  
def unsigned( string ):
    if hexfmt.match( string ) is not None:
        return string[2:].upper()

    if intfmt.match( string ) is not None:
        val = int( string )
        if val > 65536:
            raise ValueError( 'Maximum value is 65536 (0x10000)' )
        return hex( val )[2:].upper()

    raise TypeError( 'Only positive decimal or hex int values are allowed' )

def ipaddress( string ):
    if ipaddr.match( string ) is not None:
        a = string.split( '.' )
        for n in a:
            if int( n ) > 255:
                    raise TypeError( 'Not a valid IP address' )

        return string

    raise TypeError( 'Not a valid IP address' )

def adrange( string ):
    if adrrng.match( string ) is not None:
        a = string.split( '-' )

        start = int( a[0], 16 )
        end = int( a[1], 16 )

        if start > end:
            raise TypeError( 'Not a valid address range' )

        count = end - start + 1

        return [ hex( start )[2:].upper(), hex( count )[2:].upper() ]

    raise TypeError( 'Not a valid address range' )



def read( parser: argparse.ArgumentParser, address, start, count, output, format ):


    offset = int( start, 16 )

    if offset > 0xffff:
        parser.print_usage()
        print( PROGRAM_NAME + ' read: error: Offset out of range (max is 0xFFFF)', file=sys.stderr )
        return( os.EX_USAGE )

    if int( count, 16 ) > 0x10000-offset:
        count = hex( 0x10000-offset )

    params = { 'start' : start, 'count' : count }

    r = requests.get( 'http://' + address + '/ramrom/range', params=params )

    conv = bytearray()
    if format != 'raw':
        for n in range( 0, len( r.content ), 2 ):
            conv.append( r.content[n] )
    else:
        conv = r.content

    filemode = ''

    match format:
        case 'ihex':
            ih = IntelHex()
            ih.frombytes( conv, offset=offset )
            sio = StringIO()
            ih.write_hex_file( sio )
            formatted = sio.getvalue()
            sio.close()
        case 'bin' | 'raw' | 'prg':
            formatted = bytes( conv )
            filemode = 'b'
        case _:
            formatted = str( hexdump( conv, offset ) )

    if output is None:
        if format == 'bin' or format == 'raw' or format == 'prg':
            parser.print_usage()
            print( PROGRAM_NAME + ' read: error: -o/--output is required for \'bin\', \'prg\' and \'raw\' formats', file=sys.stderr )
            return( os.EX_USAGE )
        file = sys.stdout
    else:
        try:
            file = open( output, 'w' + filemode )
        except Exception as e:
            print( PROGRAM_NAME + ' read: error: ' + str(e), file=sys.stderr )
            return( os.EX_OSFILE )

    if format == 'prg':
        file.write( offset.to_bytes(2, 'little') )

    file.write( formatted )

    file.close()

    return( os.EX_OK )



def write( parser: argparse.ArgumentParser, address, start, input, format, string, enable ):

    match format:
        case 'ihex' | 'prg':
            if input is None:
                parser.print_usage()
                print( PROGRAM_NAME + ' write: error: -i/--input is required for \'ihex\' and \'prg\' formats', file=sys.stderr )
                return( os.EX_USAGE )
            if start is not None:
                print( PROGRAM_NAME + ' write: warning: -s ignored with \'ihex\' and \'prg\' formats', file=sys.stderr )

        case 'bin' | 'raw':
            if ( input is None and string is None ) or ( input is not None and string is not None ):
                parser.print_usage()
                print( PROGRAM_NAME + ' write: error: either -i/--input or a data string required for \'bin\' or \'raw\' formats', file=sys.stderr )
                return( os.EX_USAGE )

            if start is None:
                parser.print_usage()
                print( PROGRAM_NAME + ' write: error:  -s/--start is required for \'bin\' and \'raw\' formats', file=sys.stderr )
                return( os.EX_USAGE )

    match format:
        case 'ihex':
            ih = IntelHex()

            try:
                ih.fromfile( input, format='hex' )
            except Exception as e:
                print( PROGRAM_NAME + ' write: error: ' + str(e), file=sys.stderr )
                return( os.EX_OSFILE )

            start = hex( ih.minaddr() )[2:]
            print( PROGRAM_NAME + ' write: writing to offset ' + start, file=sys.stderr )
            data = ih.tobinarray()

        case 'bin' | 'raw' | 'prg':

            if input is not None:
                try:
                    file = open( input, 'rb' )
                except Exception as e:
                    print( PROGRAM_NAME + ' write: error: ' + str(e), file=sys.stderr )
                    return( os.EX_OSFILE )

                if format == 'prg':
                    if ( os.stat( input ).st_size  < 3 ):
                        print( PROGRAM_NAME + ' write: error: invalid file size', file=sys.stderr )
                        return( os.EX_OSFILE )

                    start = hex( struct.unpack( '<h', file.read( 2 ) )[0] )[2:]

                data = file.read()

                file.close()

            else:
                data = bytes( string, 'ascii' ).decode( 'unicode_escape' ).encode( 'iso-8859-1' )

    url = '/ramrom/range'
    if format != 'raw':
        url += '/data'
    else:
        if len( data ) % 2:
            print( PROGRAM_NAME + ' write: error: data length must be even for \'raw\' format', file=sys.stderr )
            return( os.EX_DATAERR )

    params = { 'start' : start }
    headers = { 'Content-Type': 'application/octet-stream' }

    r = requests.patch( 'http://' + address + url,
                        params=params, headers=headers,
                        data=data )

    if enable == True:
        params = { 'start' : start, 'count' : len( data ) }
        headers = { 'Content-Type': 'application/octet-stream' }

        r = requests.patch( 'http://' + address + '/ramrom/range/enable',
                        params=params, headers=headers,
                        data=None )

    return( os.EX_OK )



def print_section( file, start, endsect, attr_mask, enabled, readonly ):
    print( '---', file=file )
    print( 'start: '   + f'{start:#0{6}x}', file=file  )
    print( 'end: '     + f'{endsect:#0{6}x}', file=file  )
    if attr_mask | MEM_ATTR_CE_MASK:
        print( 'enabled: ' + str(enabled).lower(), file=file  )
    if attr_mask | MEM_ATTR_RW_MASK:
        print( 'type: ' + ( 'rom' if readonly is True else 'ram' ), file=file  )

def config( parser: argparse.ArgumentParser, address, enable, disable, readonly, writable, input, output ):

    url = 'http://' + address + '/ramrom/range'

    if enable is None and disable is None and readonly is None and writable is None and input is None:

        params = { 'start' : '0', 'count' : '10000' }

        r = requests.get( url, params=params )

        if output is None:
            file = sys.stdout
        else:
            try:
                file = open( output, 'w' )
            except Exception as e:
                print( PROGRAM_NAME + ' config: error: ' + str(e), file=sys.stderr )
                return( os.EX_OSFILE )

        attr_mask = MEM_ATTR_CE_MASK | MEM_ATTR_RW_MASK
        last = 0xffff
        start = 0
        section = 0
        endsect = -1
        enabled = False
        readonly= False

        for n in range( 0, len( r.content ), 2 ):
            data = int.from_bytes( r.content[n:n+2], 'little', signed=False )

            if ( data & attr_mask ) != last:
                if section > 0:
                    print_section( file, start, endsect, attr_mask, enabled, readonly )

                # New section
                #
                section += 1
                last = data & attr_mask
                start = trunc( n/2 )
                endsect += 1
                enabled = bool( not (data & MEM_ATTR_CE_MASK) )
                readonly = bool( not (data & MEM_ATTR_RW_MASK) )
            else:
                endsect += 1

        # Write last section
        print_section( file, start, endsect, attr_mask, enabled, readonly )

        file.close()

        return os.EX_OK

    else:
        if output is not None:
            print( PROGRAM_NAME + ' config: warning: -o FILE ignored', file=sys.stderr )

    headers = { 'Content-Type': 'application/octet-stream' }

    ## FIXME: DO PROPER VALIDATION
    #
    if input is not None:
        config = yaml.safe_load_all( open( input, 'r' ) )

        for value in config:
            if 'start' not in value or 'end' not in value or value['start'] is None or value['end'] is None:
                print( PROGRAM_NAME + ' read: error: invalid config format: \'start\' and \'end\' are mandatory' )
                return( os.EX_CONFIG )
            if 'type' in value and (value['type'] is None or (value['type'] != 'ram' and value['type'] != 'rom')):
                print( PROGRAM_NAME + ' read: error: invalid config format: \'' + value['type'] +'\' is not a valid type' )
                return( os.EX_CONFIG )
            if 'enabled' in value and (value['enabled'] is None or type(value['enabled']) is not bool):
                print( PROGRAM_NAME + ' read: error: invalid config format: \'enabled\' must be true or false' )
                return( os.EX_CONFIG )
            if 'fill' in value and (value['fill'] is None or type(value['fill']) is not int or value['fill'] > 255):
                print( PROGRAM_NAME + ' read: error: invalid config format: \'fill\' must be an 8bit integer' )
                return( os.EX_CONFIG )
            if 'file' in value and (value['file'] is None or not os.path.exists(value['file'])):
                print( PROGRAM_NAME + ' read: error: invalid config format: Invalid or non-existent data file' )
                return( os.EX_CONFIG )

            start = value['start']
            end = value['end']
            count = end - start + 1

            if count < 1:
                print( PROGRAM_NAME + ' read: error: invalid config format: bad address range' )
                return( os.EX_CONFIG )

            params = { 'start' : hex( start )[2:], 'count' : hex( count )[2:] }

            if 'fill' not in value and 'file' not in value:
                if 'enabled' in value and value['enabled']:
                    resource = '/enable'
                else:
                    resource = '/disable'
                r = requests.patch( url + resource,
                        params=params, headers=headers,
                        data=None )
                
                if 'type' in value:
                    resource = '/set' + value['type']
                else:
                    resource = '/setrom'
                r = requests.patch( url + resource,
                        params=params, headers=headers,
                        data=None )
            else:
                # By default, disabled and read only
                attributes = MEM_ATTR_CE_MASK
                if 'enabled' in value and value['enabled'] == True:
                        attributes &= ~MEM_ATTR_CE_MASK
                if 'type' in value and value['type'] == 'ram':
                        attributes |= MEM_ATTR_RW_MASK
                attributes = attributes >> 8

                data = bytearray()
                if 'file' in value:
                    fname = value['file']
                    file = open( fname, 'rb' )
                    if os.stat( fname ).st_size > count:
                        print( PROGRAM_NAME + ' config: warning: \'' + fname + '\' too big, truncating to ', count, ' bytes.', file=sys.stderr )
                    data = bytearray( file.read( count ) )
                    file.close()

                if 'fill' in value:
                    fill = value['fill']
                else:
                    fill =  0

                i = len( data )
                while i < count:
                    data.append( fill )
                    i += 1

                conv = bytearray()
                for n in data:
                    conv.append( n )
                    conv.append( attributes )

                r = requests.patch( url, params=params, headers=headers, data=bytes( conv ) )

    if disable is not None:
        for block in disable:
            params = { 'start' : block[0], 'count' : block[1] }
            r = requests.patch( url + '/disable',
                        params=params, headers=headers,
                        data=None )

    if enable is not None:
        for block in enable:
            params = { 'start' : block[0], 'count' : block[1] }
            r = requests.patch( url + '/enable',
                        params=params, headers=headers,
                        data=None )

    if readonly is not None:
        for block in readonly:
            params = { 'start' : block[0], 'count' : block[1] }
            r = requests.patch( url + '/setrom',
                        params=params, headers=headers,
                        data=None )

    if writable is not None:
        for block in writable:
            params = { 'start' : block[0], 'count' : block[1] }
            r = requests.patch( url + '/setram',
                        params=params, headers=headers,
                        data=None )

    return( os.EX_OK )



def generate_memmap( memory ):

    data = bytearray( 64 * 1024 )

    view = memoryview( data )

    if input is not None:
        config = list( yaml.safe_load_all( open( memory, 'r' ) ) )

        ## Pass one
        for value in config:
            if 'start' not in value or value['start'] is None:
                print( PROGRAM_NAME + ' setup: error: invalid config format: \'start\' is mandatory' )
                return None
            if ('end' not in value or value['end'] is None) and 'file' not in value and 'data' not in value:
                print( PROGRAM_NAME + ' setup: error: invalid config format: \'end\' is mandatory if \'file\' and \'data\' are not specified' )
                return None
            if 'end' in value and value['end'] is None:
                print( PROGRAM_NAME + ' setup: error: invalid config format: \'ens\' must have a value' )
                return None
            if 'type' in value and (value['type'] is None or (value['type'] != 'ram' and value['type'] != 'rom')):
                print( PROGRAM_NAME + ' setup: error: invalid config format: \'' + value['type'] +'\' is not a valid type' )
                return None
            if 'enabled' in value and (value['enabled'] is None or type(value['enabled']) is not bool):
                print( PROGRAM_NAME + ' setup: error: invalid config format: \'enabled\' must be true or false' )
                return None
            if 'fill' in value and (value['fill'] is None or type(value['fill']) is not int or value['fill'] > 255):
                print( PROGRAM_NAME + ' setup: error: invalid config format: \'fill\' must be an 8bit integer' )
                return None
            if 'file' in value and (value['file'] is None or not os.path.exists(value['file'])):
                print( PROGRAM_NAME + ' setup: error: invalid config format: Invalid or non-existent data file' )
                return None
            if 'data' in value and value['data'] is None:
                print( PROGRAM_NAME + ' setup: error: invalid config format: \'data\' must be an ascii string' )
                return None
            if 'data' in value and 'file' in value:
                print( PROGRAM_NAME + ' setup: error: invalid config format: \'data\' and \'file\' are mutually exclusive' )
                return None

            start = value['start']
            end = value['end'] if 'end' in value else None
            count = end - start + 1 if end is not None else None

            if count is not None and count < 1:
                print( PROGRAM_NAME + ' read: error: invalid config format: bad address range' )
                return( os.EX_CONFIG )

            if 'file' in value:
                fname = value['file']
                file = open( fname, 'rb' )

                if count is None:
                    count = os.stat( fname ).st_size
                    end = start + count - 1
                    value['end'] = end
                else:
                    if os.stat( fname ).st_size > count:
                        print( PROGRAM_NAME + ' config: warning: \'' + fname + '\' too big, truncating to ', count, ' bytes.', file=sys.stderr )

                file.readinto(view[start:])

                start += os.stat(fname).st_size

                file.close()

            if 'data' in value:
                bstring = bytes( value['data'], 'ascii' ).decode( 'unicode_escape' ).encode( 'iso-8859-1' )

                if count is None:
                    count = len( bstring )
                    end = start + count - 1
                    value['end'] = end
                else:
                    if len( bstring ) > count:
                        print( PROGRAM_NAME + ' config: warning: data string too big, truncating to ', count, ' bytes.', file=sys.stderr )

                pos = slice(start, start + len( bstring ))
                data[pos] = bstring

                start += len( data )

            if 'fill' in value:
                fill = value['fill']
            else:
                fill =  0xff

            while start <= end:
                data[start] = fill
                start += 1

        conv = []
        for n in data:
            reverse = int( '{:08b}'.format( n )[::-1], 2 )
            conv.append( n )
            conv.append( MEM_ATTR_CE_MASK >> 8)

        # pass two
        for value in config:
            start = value['start']
            end = value['end']

            if 'enabled' in value:
                enabled = value['enabled']
            else:
                enabled = False

            if 'type' in value:
                memtype = value['type']
            else:
                memtype = 'rom'

            while start <= end:
                if enabled == True:
                    conv[start*2+1] &= (~MEM_ATTR_CE_MASK) >> 8
                if memtype == 'ram':
                    conv[start*2+1] |= MEM_ATTR_RW_MASK >> 8

                start += 1


    return conv

country_codes = ['US', 'CA', 'JP3', 'DE', 'NL', 'IT', 'PT', 'LU', 'NO', 'FI', 'DK', 'CH', 'CZ', 'ES',
                 'GB', 'KR', 'CN', 'FR', 'HK', 'SG', 'TW', 'BR', 'IL', 'SA', 'LB', 'AE', 'ZA', 'AR',
                 'AU', 'AT', 'BO', 'CL', 'GR', 'IS', 'IN', 'IE', 'KW', 'LI', 'LT', 'MX', 'MA', 'NZ',
                 'PL', 'PR', 'SK', 'SI', 'TH', 'UY', 'PA', 'RU', 'KW', 'LI', 'LT', 'MX', 'MA', 'NZ',
                 'PL', 'PR', 'SK', 'SI', 'TH', 'UY', 'PA', 'RU', 'EG', 'TT', 'TR', 'CR', 'EC', 'HN',
                 'KE', 'UA', 'VN', 'BG', 'CY', 'EE', 'MU', 'RO', 'CS', 'ID', 'PE', 'VE', 'JM', 'BH',
                 'OM', 'JO', 'BM', 'CO', 'DO', 'GT', 'PH', 'LK', 'SV', 'TN', 'PK', 'QA', 'DZ']

UF2_MAGIC_FIRST     = 0x0A324655        # "UF2\n"
UF2_MAGIC_SECOND    = 0x9E5D5157
UF2_MAGIC_FINAL     = 0x0AB16F30
UF2_FLAGS           = 0x00002000        # familyID present
UFS_BLOCK_DATA      = 0x00000100        # 256 bytes
UF2_PICO_FAMILY     = 0xE48BFF56

MEMMAP_START_ADDR   = 0x101C0000
CONFIG_START_ADDR   = 0x101E0000

def setup( parser: argparse.ArgumentParser, wifi, memory, output ):
    if wifi is None and memory is None:
        parser.print_usage()
        print( PROGRAM_NAME + ' setup: error: either -w/--wifi or -m/--memory are required', file=sys.stderr )
        return( os.EX_USAGE )

    nblocks = 0

    if memory is not None:
        if not os.path.exists( memory ):
            parser.print_usage()
            print( PROGRAM_NAME + ' setup: error: File \'' + memory + '\' does not exist', file=sys.stderr )
            return( os.EX_CONFIG )

        data = generate_memmap( memory )

        if data is None:
            return( os.EX_CONFIG )

        bdata = bytearray( data )
    else:
        bdata = bytearray()

    if wifi is not None:
        if not os.path.exists( wifi ):
            parser.print_usage()
            print( PROGRAM_NAME + ' setup: error: File \'' + wifi + '\' does not exist', file=sys.stderr )
            return( os.EX_CONFIG )

        config = yaml.safe_load_all( open( wifi, 'r' ) )

        for values in config:
            if 'country' not in values:
                print( PROGRAM_NAME + ' setup: error: \'country\' is mandatory in config file', file=sys.stderr )
                return( os.EX_CONFIG )
            if 'ssid' not in values:
                print( PROGRAM_NAME + ' setup: error: \'ssid\' is mandatory in config file', file=sys.stderr )
                return( os.EX_CONFIG )
            if 'password' not in values:
                print( PROGRAM_NAME + ' setup: error: \'password\' is mandatory in config file', file=sys.stderr )
                return( os.EX_CONFIG )

            if values['country'] not in country_codes:
                print( PROGRAM_NAME + ' setup: error: invalid country code: \'' + values['country'] + '\'', file=sys.stderr )
                return( os.EX_CONFIG )

            if len(values['ssid']) > 31:
                print( PROGRAM_NAME + ' setup: error: SSID name too long, max. is 31 chars.', file=sys.stderr )
                return( os.EX_CONFIG )

            if len(values['password']) > 63:
                print( PROGRAM_NAME + ' setup: error: password too long, max. is 63 chars.', file=sys.stderr )
                return( os.EX_CONFIG )

            #b = values['country'].encode('utf-8').ljust(4, b'\0')

            bdata.extend( values['country'].encode('utf-8').ljust(4, b'\0') )
            bdata.extend( values['ssid'].encode('utf-8').ljust(32, b'\0') )
            bdata.extend( values['password'].encode('utf-8').ljust(64, b'\0') )

    uf2 = bytearray()

    if memory is not None:
        data_offset = MEMMAP_START_ADDR
    else:
        data_offset = CONFIG_START_ADDR

    for i in range(0, len(bdata), 256):
        block_data = bdata[i:i+256]

        header = struct.pack('<IIIIIIII',
            UF2_MAGIC_FIRST,            # "UF2\n" little endian
            UF2_MAGIC_SECOND,           # Second magic number
            UF2_FLAGS,                  # Flags
            i+data_offset,              # Data destination
            256,                        # Data size
            i // 256,                   # Block no.
            (len(bdata) + 256) // 256,  # Total no. of blocks
            UF2_PICO_FAMILY             # Family
        )

        uf2.extend( header )
        uf2.extend( block_data )
        uf2.extend( b'\0' * ( 508 - len( header ) - len( block_data ) ) )  # Relleno
        uf2.extend( struct.pack('<I', UF2_MAGIC_FINAL ) )

    file = open( output, 'wb' )

    file.write( uf2 )

    file.close()

    return( os.EX_OK )



# Frmatter class credit: https://stackoverflow.com/users/901925/hpaulj
#
def main():
    class Formatter(argparse.HelpFormatter):
        # use defined argument order to display usage
        def _format_usage(self, usage, actions, groups, prefix):
            if prefix is None:
                prefix = 'usage: '

            # if usage is specified, use that
            if usage is not None:
                usage = usage % dict(prog=self._prog)

            # if no optionals or positionals are available, usage is just prog
            elif usage is None and not actions:
                usage = '%(prog)s' % dict(prog=self._prog)
            elif usage is None:
                prog = '%(prog)s' % dict(prog=self._prog)
                # build full usage string
                action_usage = self._format_actions_usage(actions, groups) # NEW
                usage = ' '.join([s for s in [prog, action_usage] if s])
                # omit the long line wrapping code
            # prefix with 'usage:'
            return '%s%s\n\n' % (prefix, usage)

    parser = argparse.ArgumentParser(
                prog=PROGRAM_NAME,
                description='Mememul configure tool',
                epilog='Copyright (C) Eduardo Casino https://github.com/eduardocasino' )
    subparsers = parser.add_subparsers( title='commands', dest='cmd' )

    parser_r = subparsers.add_parser( 'read', help='Read data from the memory emulator', formatter_class=Formatter )
    parser_r.add_argument( 'address', metavar='IPADDR', type=ipaddress, help='Board IP address' )
    parser_r.add_argument( '-s', '--start',   metavar='OFFSET', required=True, type=unsigned, help='Start offset' )
    parser_r.add_argument( '-c', '--count',   default='0x100', type=unsigned, help='Bytes to transfer' )
    parser_r.add_argument( '-f', '--format',  choices=['hexdump', 'bin', 'ihex', 'prg', 'raw'], default='hexdump', help='Output format (default: %(default)s)' )
    parser_r.add_argument( '-o', '--output',  metavar='FILE', help='File to output data to' )

    parser_w = subparsers.add_parser('write', help='Write data to the memory emulator', formatter_class=Formatter )
    parser_w.add_argument( 'address', metavar='IPADDR', type=ipaddress, help='Board IP address' )
    parser_w.add_argument( '-s', '--start',   metavar='OFFSET', type=unsigned, help='Start address' )
    parser_w.add_argument( '-f', '--format',  required=True, choices=['bin', 'ihex', 'prg', 'raw'], help='Input format (default: %(default)s)' )
    parser_w.add_argument( '-i', '--input',   metavar='FILE', help='File to input data from' )
    parser_w.add_argument( '-e', '--enable',  action='store_const', const=True, default=False, help='Enable the address range' )
    parser_w.add_argument( '-d', '--data',    metavar='STRING', dest='string', help='Data string' )

    parser_c = subparsers.add_parser('config', help='Configure address ranges of the memory emulator', formatter_class=Formatter )
    parser_c.add_argument( 'address', metavar='IPADDR', type=ipaddress, help='Board IP address' )
    parser_c.add_argument( '-d', '--disable',  metavar='RANGE', type=adrange, nargs='+', help='Disable the address range(s)' )
    parser_c.add_argument( '-e', '--enable',   metavar='RANGE', type=adrange, nargs='+', help='Enable the address range(s)' )
    parser_c.add_argument( '-r', '--readonly', metavar='RANGE', type=adrange, nargs='+', help='Make the address range(s) read-only (ROM)' )
    parser_c.add_argument( '-w', '--writable', metavar='RANGE', type=adrange, nargs='+', help='Make the address range(s) writable (RAM)' )
    parser_c.add_argument( '-i', '--input',    metavar='FILE', help='File to read the config from' )
    parser_c.add_argument( '-o', '--output',   metavar='FILE', help='File to save the config to' )

    parser_s = subparsers.add_parser('setup', help='Generates an UF2 file for board configuration' )
    parser_s.add_argument( '-w', '--wifi', metavar='FILE', help='WiFi configuration file' )
    parser_s.add_argument( '-m', '--memory', metavar='FILE', help='Default memory map file' )
    parser_s.add_argument( '-o', '--output', metavar='FILE', required=True, help='Generated UF2 file' )

    args = parser.parse_args()

    # print ( args )

    ret = os.EX_OK
    match args.cmd:
        case 'read':
            ret = read( parser_r, args.address, args.start, args.count, args.output, args.format )
        case 'write':
            ret = write( parser_w, args.address, args.start, args.input, args.format, args.string, args.enable )
        case 'config':
            ret = config( parser_c, args.address, args.enable, args.disable, args.readonly, args.writable, args.input, args.output )
        case 'setup':
            ret = setup( parser_s, args.wifi, args.memory, args.output  )
        case _:
            parser.print_usage()
            print( PROGRAM_NAME + ' error: argument cmd is mandatory (choose from \'read\', \'write\', \'config\' or \'setup\')', file=sys.stderr )
            ret = os.EX_USAGE

if __name__ == '__main__':
    main()