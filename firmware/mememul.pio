// Notes about timings (see the 6502 datasheet):
//
// READ LOOP
//
// memread is decoding and checking addresses in a loop that takes about 100ns so, even if in one
// loop the address is still not valid because it is too early in the clock cycle, there is no
// problem because the processor wont read the bus until the end of the cycle, which will happen
// more or less 9 loops later.
//
// The read loop also checks for the RAMRW signal and ensures that, if it is high, the address
// is writeable. RAMRW can only be high when 02 is also high, i.e. at the second half of the cycle.
// That means that when RAMRW is high, the address bus is guaranteed to have the correct address.
// After detecting it is a write operation, memread read the write flag in the memory and, if it
// is set, enables de CE pin, flags memwrite to start and waits for it to finisl.
// After that, memwrite enters the scene:
//
// WRITE LOOP
//
// TODO
//
// TABLE: PROPAGATION DELAYS FOR RAMRW
//
//                 MAX           TYP
//    74HCT x 2 -> 50ns extra    28ns extra
//    74LS  x 2 -> 30ns extra    20ns extra
//    74    x 2 -> 44ns extra    24ns extra
//

.define GPIO_CE 16

// Configure: IN  pins:     ADDR
//            OUT pins:     DATA
//            SIDE SET pin: CE
//            JMP pin:      RAMRW
//
// The RX FiFo is read_addr_dma read address
// The TX FiFo is read_data_dma write address
//
.program memread
.side_set 1 opt
    pull    block               // Get address header, top 15 bits and
    mov     x osr               // put into x and leave there forever

.wrap_target
restart:
    mov     isr x               // Get top 15 bits from x, when combined forms a 32bit address in Pico memory
    in      pins 16             // Shift in the bottom 16 bits from gpio pins to ISR
    in      null 1              // and multiply by 2 (16 bit transfers)
                                // At this point, autopush puts the address into the RX FiFo, signals the read_addr_dma
                                // channel to initiate transfer, which puts it as read address for read_data_dma, then
                                // chains to write_addr_dma, which immediately copies the read address of read_data_dma into
                                // the write address trigger of write_data_dma and then chains to read_data_dma,
                                // which immediately places the contents of the read address into the TX FiFo and chains to
                                // read_addr_dma to start over.
    jmp     pin write           // If it is a write operation, jump

    mov     osr !null           // Fill the OSR with ones
    out     pindirs 11          // Set data pins as outputs
    pull
    out     y 1                 // Get #CE flag bit into Y
    jmp     !y cont_read        // If the address is enabled, jump and continue
    jmp     restart     side 1  // Else set CE high and restart

cont_read:
    out     pins 11             // Read: Shift 11 bits (8 bit word + 3 unused) from OSR to gpio pins
    jmp     restart     side 0  // And restart with CE enabled

write:
    pull
    out     y 1                 // Get #CE flag bit into Y
    jmp     !y cont_write       // If the address is enabled, jump and continue
    jmp     restart     side 1  // Else, discard rest of OSR and abort with CE disabled

cont_write:
    out     null 11             // Discard data byte + 3 unused bits
    out     y 1                 // Get RW flag bit into Y
    jmp     !y restart  side 1  // If not RW memory, set CE high and restart
    irq     6           side 0  // Signals memwrite, enables CE,
    irq     wait 7              // sets IRQ 7 and waits for it to clear before continuing
.wrap


// Configure: IN  pins: DATA
//            JMP pin:  RAMRW
//
// The RX FiFo is write_data_dma read address
//
.program memwrite
.wrap_target
start:
    wait    1 irq 6             // Waits for semaphore to start

    mov     osr null            // Fill OSR with zeroes
    out     pindirs 11  [12]    // Set pin directions to input
                                // Maximum data setup time of 200ns, minus minimum propagation
                                // delay for RAMRW of 20s, equals 180ns. There are 11 instructions
                                // (88ns) before reaching the in instruction, so we need 100 extra ns
                                // or a bit more of 12 cycles, so we add that to the previous
                                // instruction to allow for the data to stabilize

    in      pins 12             // Read the data bus (8 bit word + 3 unused + RW)
    in      null 1      [2]     // Shift memory enable flag into the ISR
                                // 50ns max propagation delay for RAMRW, minus 30ns minimum data hold
                                // for the write operation equals 20ns (~3 cycles), so we add 2
                                // to the previous operation before checking if RAMRW is still active
    jmp     pin continue        // Re-check that RAMRW is still set
    jmp     restart             // else, abort

continue:
    push                [7]     // move ISR to input FiFo, this signals the write_data_dma channel,
                                // which has its config write address trigger configured by
                                // write_addr_dma, to start transfer. Wait a bit to ensure it is done
restart:
    irq     clear 7             // Flags memread to resume execution
.wrap

