// Notes about timings (see the 6502 datasheet):
//
// READ LOOP
//
// memread is decoding and checking addresses in a loop that takes about 100ns so, even if in one
// loop the address is still not valid because it is too early in the clock cycle, there is no
// problem because the processor wont read the bus until the end of the cycle, which will happen
// more or less 9 loops later.
//
// The read loop also checks for the RAMRW signal and ensures that, if it is high, the address
// is writeable. RAMRW can only be high when 02 is also high, i.e. at the second half of the cycle.
// That means that when RAMRW is high, the address bus is guaranteed to have the correct address.
// After detecting it is a write operation, memread read the write flag in the memory and, if it
// is set, enables de CE pin. This takes 5 operations or 40ns. After that, memwrite enters the
// scene:
//
// WRITE LOOP
//
// memwrite checks the CE pin, checks also that RAMRW is set, and changes the data bus direction.
// That takes 4 instructions or 32ns which, added to the previous 40ns makes a total of 72ns. There
// are two potentially problematic scenarios:
//
// 1. memread reads RAMRW just at the moment it becomes high. At that point, data is not guaranteed
//    to be stable until Tmds later, which takes between 20ns and 175ns. That means that in a
//    percentage of the cases, the data written to memory will be invalid. But, the memwrite loop
//    repeats each 6 instructions or 48ns, which means that it will get the valid data eventually
//    and long before the RAMRW goes low again, so no problems here.
// 2. memread reads RAMRW just before it goes low. In that case, the data bus will remain valid
//    for Thw, which varies between 60ns and 150ns. As we saw before, it will take about 72ns
//    to reach the point in which memwrtite reads the data bus, so there is a chance that the
//    data will be no longer valid. BUT, memwrite is checking that RAMRW is still set just an
//    instruction or 8ns before reading the data bus, so it guarantees that the data will be valid.
//
// NOTE: I did not take into account the propagation delays of the gates in the RAMRW path. Original
//       KIM-1 has 74xx logic and there are 3 gates in the path. Mi replica has 74HCT. So, assuming
//       typical values, we should still be OK...
//
//               MAX           TYP
//  74HCT x 3 -> 75ns extra    42ns extra
//  74LS  x 3 -> 45ns extra    30ns extra
//  74    x 3 -> 66ns extra    36ns extra
//
.define GPIO_CE 16

// Configure: IN  pins: ADDR
//            OUT pins: DATA
//            SET pin:  CE
//            JMP pin:  RAMRW
//
// The RX FiFo is read_addr_dma read address
// The TX FiFo is read_data_dma write address
//
.program memread
    set     pins 1              // CE disabled by default
    pull    block               // Get address header, top 15 bits and
    mov     x osr               // put into x and leave there forever
.wrap_target
start:
    mov     isr x               // Get top 15 bits from x, when combined forms a 32bit address in Pico memory
    in      pins 16             // Shift in the bottom 16 bits from gpio pins to ISR
    in      null 1              // and multiply by 2 (16 bit transfers)
                                // At this point, autopush puts the address into the RX FiFo, signals the read_addr_dma
                                // channel to initiate transfer, which puts it as read address for read_data_dma, then
                                // chains to write_addr_dma, which immediately copies the read address of read_data_dma into
                                // the write address trigger of write_data_dma and then chains to read_data_dma,
                                // which places the contents of the read address into the TX FiFo and chains to read_addr_dma
                                // to start over.Autopull pulls the TX FiFo into the OSR.( See piocfg_setup() )

    out     y 1                 // Get #CE flag bit into Y
    jmp     !y chk_write        // If the address is enabled, jump

    set     pins 1              // Disabled, set CE gigh
    out     null 12             // Discard the rest of the OSR, autopull enabled
    jmp     start               // And restart

chk_write:
    jmp     pin write           // If it is a write operation, jump to it
    
    out     pins 11             // Read: Shift 11 bits (8 bit word + 3 unused) from OSR to gpio pins
    out     null 1              // Discard the RW flag bit, autopull enabled
    set     pins 0              // Enable buffers (CE low)
    jmp     start               // And restart

write:
    out     null 11             // Discard data byte + 3 unused bits
    out     y 1                 // Get RW flag bit into Y, autopull enabled
    jmp     !y start            // If not RW memory, restart

    set     pins 0              // Enable buffers (CE low) and restart
.wrap


// Configure: IN  pins: DATA
//            JMP pin:  RAMRW
//
// The RX FiFo is write_data_dma read address
//
.program memwrite
.wrap_target
start:
    wait    0 gpio  GPIO_CE     // Wait until chip enable
    mov     osr null            // Fill OSR with zeroes
    out     pindirs 11          // Set pin directions to input
    jmp     pin continue        // Check that RAMRW is set
    jmp     start               // If not, abort
continue:
    in      pins 12             // Read the data bus (8 bit word + 3 unused + RW)
    in      null 1              // Shift CE enabled into isr. Autopush moves ISR to input FiFo,
                                // this signals the write_data_dma channel, which has its config
                                // write address trigger configured by write_addr_dma, to start transfer
.wrap

